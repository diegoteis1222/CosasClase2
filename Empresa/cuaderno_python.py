# -*- coding: utf-8 -*-
"""cuaderno python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jpXIVY7HGegyYpPOVHw98Ha6dpGyoSTq

>[¿Qué es Python?](#scrollTo=cskTHG87W3ig)

>[Características](#scrollTo=WOxp3SLQXI7u)

>[Print](#scrollTo=5SlapkXKQS9I)

>[Operadores aritméticos](#scrollTo=BGyVG-uDUplf)

>>[Operadores](#scrollTo=0q4rk62I_Yzu)

>>[Operadores de comparación](#scrollTo=umeMregr_oEd)

>[Lectura por teclado](#scrollTo=b0GdkSZw483F)

>[Tipos de variables](#scrollTo=faxLCmgKQcz-)

>>[Cadenas](#scrollTo=IVJnR5glQlFq)

>[Colecciones](#scrollTo=JfD-BusnPF_r)

>>[Listas](#scrollTo=covqdQnmPPAK)

>>[Tuplas](#scrollTo=vet0Lbl2Jss6)

>>[Conjuntos (set)](#scrollTo=TYE10vTvxb9P)

>>[Diccionarios](#scrollTo=r4xKT2j72qsr)

>>[Pilas](#scrollTo=PhgssyXU8BMh)

>>[Colas](#scrollTo=IwL0H0N68DdA)

>[Estructuras de control](#scrollTo=4MPWba_0AArd)

>>[IF](#scrollTo=o5fhDhwIAF9f)

>>[if else](#scrollTo=xLgRAasFA_N_)

>>[else if (elif)](#scrollTo=jAu3AvuNBSIp)

>>[if simplificado](#scrollTo=zPKym_z11p_y)

>>[Ejercicio](#scrollTo=dxf2194KB0wQ)

>>[If in](#scrollTo=ERxHQlYlESrf)

>>[Switch (segun sea)](#scrollTo=WLjEsB4nEuto)

>>[While (mientras)](#scrollTo=8xacH4DxE2v_)

>>[While else](#scrollTo=K-uMkEukFTMu)

>>[break](#scrollTo=PbLnFksWFlVv)

>>[continue](#scrollTo=z7FKJQShGLqL)

>>[bucle iterativo for in](#scrollTo=FznWjxwgGdxR)

>>[Enumerate](#scrollTo=WjZUTJVnH2lo)

>>[for range](#scrollTo=1Y7d8e1gIW7V)

>[Argumentos de la linea de comandos](#scrollTo=LIp4hPNwBRzW)

>[Funciones](#scrollTo=SB7ABYlILaWK)

>>[Parametros por valor y por referencia](#scrollTo=NcfOuo-hfCsu)

>>[Parámetros indeterminados](#scrollTo=-IcpAD8KWSBu)

>>[Las funciones de conversión de valores](#scrollTo=TTk5f7_5loqZ)

>>[Funciones recursivas](#scrollTo=pw7w1sOiGVKV)

>[Control de errores](#scrollTo=CmP7Lqlan5IO)

>[Clases](#scrollTo=dZx9Q6Aor2kp)

>>[Tipos de métodos en la clase](#scrollTo=LS6KxW39TmJr)

>>[Tipos de atributos](#scrollTo=1uiVMFH_aobV)

>>[Propiedades (property)](#scrollTo=Zuet6-05ckWp)

>[Los modulos](#scrollTo=kQGKy7D-oZfq)

>[Los paquetes](#scrollTo=rjRVMpKdNcWT)

>[Módulos standar](#scrollTo=6mF3KcJhRAgZ)

>[Ficheros](#scrollTo=wVgylMMRqUrL)

>>[Ficheros de tipo texto](#scrollTo=pn4Qu9uYqXLI)

>[Documentación con Docstrings](#scrollTo=IMxuvUd1EPw8)

>[Testeo con doctest](#scrollTo=SkKZ5cK3GlLc)

>[Bases de datos](#scrollTo=4van1bl1Ilgj)

>>[Uso de bases de datos sqlite](#scrollTo=wUxT6EFib2lh)

>>[Acceso a bases de datos Mysql](#scrollTo=viGQEZwZHidM)

>>[Acceso a base de datos MongoDB](#scrollTo=1wCxZyaaMAh3)

>[Formateo de cadenas](#scrollTo=wyMbeAxHItWh)

>[Funciones lambda](#scrollTo=c8FLVLhK_rhq)

>[Funciones de orden superior](#scrollTo=GvQR0nTwC6yG)

>>[map](#scrollTo=Sj78DXhtC9tV)

>>[filter](#scrollTo=f1wJL2JFIJpt)

>>[reduce](#scrollTo=Sw_kKxnSK2yf)

>>[Comprehension de listas](#scrollTo=zr4gOURYR2DJ)

# ¿Qué es Python?

Python es un lenguaje de programación interpretado y orientado a objetos, muy fácil de aprender y potente, desde mi punto de vista, recomendado para cualquier persona que desee aprender a programar, y mucho más, si desea orientar sus conocimiento a la seguridad de la información, muchas de las herramientas de hacking que se usan hoy en día, están escritas en este lenguaje

https://www.python.org/downloads/

# Características



*   sintaxis simple e intuitiva
* Software libre
* Multiplataforma
* Lenguaje con futuro
* Sirve para desarrollar casi cualquier cosa: Orientado a desarrollo de scritps, servidores web, juegos, interfaces gráficas.

# Print
"""

print("""
una linea
otra linea
otra linea mas
otra linea \t con tabulacion
""")

"""# Operadores aritméticos


*   suma +
* resta -
* multiplicacion *
* division /
* division //: cuando el resultado es positivo nos da un valor entero, truncado, quitando los decimales sin redondeo cuando es negativo se redondea hacia abajo
* modulo %
* potencia **  



"""

a = 5
b = 2
print(a - b)
print(a / b)
print(a // b)

"""## Operadores
True y False (con la primera en mayúsculas)
"""

# True / False
condicion = True

"""## Operadores de comparación

==  igual que

!=   distinto que

\>    mayor que

<    menor que

\>=  mayor o igual que

<=  menor o igual que


"""

##==

"""# Lectura por teclado

"""

# leemos dos cadenas de texto
print("Inserta un número")
v = input()
print("Inserta otro número")
b = input()
t = v+b
print(t) // la concatenación de las 2 cadenas leidas

# podemos mostrar una frase cuando pedimos un valor por teclado
v = input("Inserta un número:")

# podemos convertir a numeros lo leido por teclado
v = input("Inserta un numero")
v = int(v)
t = input("Inserta otro numero")
t = float(t)
r = v + t
print(r)

# si no se puede convertir falla lanzando una excepción
v = input("Inserta un número")
v = int(v) # si v no se puede convertir salta una excepción



"""# Tipos de variables
* En python se distingue entre mayusculas y minusculas
* no puede comenzar por número.
* no puede usar simbolos raros. Solo guión bajo, letras y números.
* Es recomendable todo en minúsculas
* No hay que declarar variables, pero no se pueden usar si no se le ha asinado un valor
* ej: nota_media

## Cadenas
"""

c="esto es una cadena\ncon 2 líneas";
c
print(c)

"""Concatenar cadenas"""

c="hola"
c + c
print(c)

s="hola" "que tal"
print(s)

"""Repetir cadenas"""

diez_espacios = " " * 10
print(diez_espacios + "hola")

"""Índices de una cadena"""

palabra="python"
s = palabra[0]  #esto es una p
print(s)
s = palabra[-1] #esto es el índice del último carácter
print(s)
s = palabra[-6] #esto sería lo mismo de 0  = p
print(s)

"""Slicing"""

palabra="python"
s = palabra[0:2]  #esto muestra py
print(s)
s = palabra[2:-1] #esto muestra tho
print(s)
s = palabra[2:] #esto muestra thon
print(s)
s = palabra[:2] #esto muestra py
print(s)
s = palabra[:] #esto muestra python
print(s)

"""Ejercicio de cadenas y slicing"""

palabra="python"

print( palabra[:2] + palabra[2:] ) # python
print( palabra[-2:] ) # on
#print( palabra[7] ) # error
print( palabra[:7] ) # python
print( palabra[7:] ) #

"""Inmutabilidad de las cadenas

*Las cadenas no se pueden cambiar*
"""

cadena="python"
cadena[0]='B' #error

# lo podemos solucionar
cadena = 'B'+cadena[1:]

"""Tamaño de las cadenas"""

palabra="python"
len(palabra) #esto valdrá 6

# conversion mayusculas, minusculas
c = "Hola mundo".upper()  # HOLA MUNDO
print(c)

c = "Hola  mundo".lower()  # hola mundo
print(c)

# pone la primera letra de la frase en mayúsculas
c = "hola mundo".capitalize() # Hola mundo
print(c)

# pone la primera letra de cada palabra en mayúcula
c = "hola mundo".title() # Hola Mundo
print(c)

c = "Der Fluß".casefold()
print(c)

# Contar el nº de veces que aparece una letra
contador = "Hola Mundo".count('o') # 2
print(contador)

#nos dice en que índice aparece una subcadena (en concreto la primera)
indice = "Hola mundo".find("mu") #5
print(indice)

#nos dice en que índica aparece una subcadena (empenzado desde el final)
indice = "Hola mundo mundano".rfind("mu") # 11
print(indice)

frase = "Esta es una frase de angel"
print(frase.count('angel'))

# Comprobar si la cadena es de algun tipo determinado
# comprobar si es un digito
c="100"
v = c.isdigit()
print(v) # True

#comprobar si es un cadena alfanumérica
c="abc123"
v = c.isalnum()
print(v) # True

#comprobar si es cadena de solo letras
c="abc"
v = c.isalpha()
print(v) # True

#si todo esta en minusculas
c="Abc"
v = c.islower()
print(v) # Falso

#si todo está en mayusculas
c="ABC"
v = c.isupper()
print(v) # true

#preguntar si la cadena es de tipo título (la primera letra en mayusculas)
c="Abc"
v = c.istitle()
print(v) # true

# preguntar si la cadena es un identificador (un nombre de variable válido)
c="45abc"
v= c.isidentifier()
print(v) # false

# preguntar si la cadena son todos espacios
c="      "
v= c.isspace()
print(v) # true

#preguntas si la cadena comienza con algo
c="Angel"
v = c.startswith("An")
print(v) #true

#preguntar si la cadena termina en algo
c="Angel"
v = c.endswith("el")
print(v) #true

#trocear textos
nombres = "Angel Bea Pepe"
lista = nombres.split() # se usara como separador el espacio
print(lista) # ["Angel", "Bea", "Pepe"]
print(lista[2]) # "Pepe"

nombres = "Angel,Bea,Pepe"
lista = nombres.split(',')
print(lista) # ["Angel", "Bea", "Pepe"]
print(lista[2]) # "Pepe"

#unir elementos (de una colección) en un texto
lista = ["Bea", "Pepe", "Angel"]
r = ":".join(lista)
print(r) #  "Bea:Pepe:Angel"

texto = "ABC"
r=":".join(texto)
print(r) # A:B:C

#eliminar espacio en los laterales
r = " hola   que         tal estas      ".strip()
print(r) #hola   que         tal estas


#elimina los caracteres de los laterales que yo le indique
r = "______hola____que__tal_estas__________".strip('_')
print(r) #hola____que__tal_estas

#reemplazar elementos
r = "Hola ola".replace("o", "a")
print(r) #Hala ala"

r = "Hola mundo mundo cruel mundo".replace("mundo", "vida")
print(r) #Hola vida vida cruel vida

#El método partition () divide la cadena en la primera aparición de la cadena de argumento y
# devuelve una tupla que contiene la parte del separador anterior,
# la cadena de argumento y la parte posterior al separador.
#Ejemplos:
string = "Python is fun"
# se encuentra el separador 'is'
print(string.partition('is '))
# no se encuentra el separador 'not'
print(string.partition('not '))
string = "Python is fun, isn't it"
# Se divide en la primera aparacion de'is'
print(string.partition('is'))

#lstrip([chars])

#Devuelve una copia de la cadena con los caracteres iniciales eliminados.
#Si no pasamos argumento, se toman los espacios en blanco iniciales.
#Si pasamos como argumento un char, este será eliminado al principio del String.
random_string = '   this is good '

# Leading whitepsace are removed
print(random_string.lstrip())

# Argument doesn't contain space
# No characters are removed.
print(random_string.lstrip('sti'))

print(random_string.lstrip('s ti'))

website = 'https://www.programiz.com/'
print(website.lstrip('htps:/.'))

"""# Colecciones

##Listas

Como crear cadenas
"""

numeros = [3,4,5]
numeros = [4, "hola", 5.6, -7, True, 'adios']
# funcionan igual que las cadenas de caracteres
v = numeros[0]
print(v) # 4
v = numeros[-1]
print(v) # el ultimo 'adios'
v = numeros[-2:] # slicing [True, 'adios']
print(v)

"""Concatenar listas"""

# concatenar listas
numeros = [3,4,5]
numeros = numeros + [6,7]
print(numeros)

# Concatenar listas (con extends)
lista1=[1,2,3]
lista2=[4,5,6]
lista1.extend(lista2) #devuelve [1,2,3,4,5,6]
print(lista1)

"""Mutabilidad de las listas"""

# Las listas son mutables. Al contrario que las tuplas. Es decir, las podemos
pares = [0,2,4,5,8,10]
pares[3] = 6
print(pares)

"""Inserción de elementos en la lista"""

# para añadir elementos a la lista (append)
pares=[0,2,4]
pares.append(6)
pares.append(4+4) # se añade 8
print(pares)

#insertar en una posición de la lista
lista=[10,15,25]
lista.insert(0,5) # [5,10,15,20]
print(lista)
lista.insert(-1,20) # -1 inserta en la penúltima posición [5,10,15,20,25]
print(lista)
lista.insert(9999,30) # se comporta como un append [5,10,15,20,25,30]
print(lista)

"""Asignaciones con slicing"""

# asignaciones con slicing
letras=['a','b','c','d','e','f']
print( letras[:3])
letras[:3] = ['A', 'B', 'C']
print(letras) # ['A', 'B', 'C', 'd', 'e', 'f']

letras[:3] = ['A', 'B', 'C', 'X']
print(letras) #  ['A', 'B', 'C', 'X', 'd', 'e', 'f']

"""Borrado de elementos de la lista"""

#borrar valores de la lista
letras=['a','b','c','d','e','f']
letras[:3] = []
print(letras) # ['d', 'e', 'f']

letras = []
print(letras) # borra todos los elementos de la lista

# Borado completo de una lista
lista = [1,2,3,4,5]
lista.clear() #devuelve una lista vacia []
print(lista)

"""Quitar elementos de la lista"""

#podemos sacar el último de la lista
lista=[1,2,3,4]
lista.pop() #devuelve [1,2,3]
print(lista)

#podemos sacar un elemento de una posición determinada
lista=[1,2,3,4]
lista.pop(0) #saca el elemento de la posición 0, devuelve [2,3,4]
print(lista)

#podemos borrar un elemento en particular (solo el primero que encuentra)
lista=[2,25,33,4,33]
lista.remove(33) #devuelve [2,25,4,33]
print(lista)

"""Calcular el tamaño de la lista"""

# el tamaño de la lista
letras=['a','b','c','d','e','f']
t = len(letras)
print(t) # 6

"""Ordenar listas"""

# ordenar listas
lista = [2,3,4,1]
lista.sort()
print(lista)

lista.sort(reverse=True)
print(lista)

lista = ['b','A','a','ñ','z']
lista.sort()
print(lista)

"""Listas anidadas"""

#Listas anidadas
a=[1,2,3]
b=[4,5,6]
c=[7,8,9]
l = [a,b,c]
v = l[0] # a la primera sublista (a)
print(v) # [1, 2, 3]
v = l[0][0] # al primer elemento de la primera lista (1)
print(v) # 1

"""Contar elementos de la lista"""

#contar los elementos de una lista
lista=[1,3,5,7,9,3]
print( lista.count(3) ) #devuelve 2, ya que el 3 está repetido 2 veces

#encontrar un elemento a partir de su índice
lista=[1,3,5,7,9,3,5]
print( lista.index(5) ) #devuelve 2 (la primera ocurrencia)

"""Invertir una lista"""

#podemos invertir una lista
lista=[2,4,7,8]
lista.reverse() #devuelve [8,7,4,2]
print(lista)

#nota, esto no vale para cadenas. "hola".reverse() error. Truco:
lista= list("hola")
lista.reverse()
cadena_volteada = "".join(lista)
print(cadena_volteada)

# Eliminar elementos de la lista (por su indice)
lista= ["apple", "banana", "cherry"]
del(lista[0])
print(lista)

# No se pude usar así del(lista)

# Sumar elementos de una lista
numbers = [2.5, 3, 4, -5]
numbersSum = sum(numbers)
print(numbersSum)

numbersSum = sum(numbers, 10)
print(numbersSum)

# Copiar 2 listas
# El método copy() nos permite copiar una lista.

lista_1=[1,2,3]
lista_2=lista_1 # <-- esto no es correcto, ya que lista_2 y lista_1 referencian a la misma lista

# forma correcta usando copy
lista_3 = lista_1.copy()

# forma correcta usando slicing
lista_4 = lista_1[:]

"""## Tuplas
Son parecidas a las listas, pero son inmutables (no se pueden modificar)
"""

tupla=(10, 'hola', 4.7, "adios", [1,2,3])
print(tupla[1]) # 'hola'
print(tupla[:-1]) # [1,2,3]
#tupla[0] = 5 # error no se pueden cambiar
#tupla.append(6) # error no se pueden cambiar
tupla[4][0] = 10
tupla[4].append(26)
#tupla[4] = [6,7,8] # error
print(tupla)

# .index nos dice en que indice se encuentra algo
tupla=(100,'hola', [1,2,3], 4.6, -30, 100)
i = tupla.index('hola') # 1
print(i)
i = tupla.index(100) # 0
print(i)
#i = tupla.index("pepe")  # lanza una excepción
#print(i)

# .count nos indica cuantos elementos de un tipo hay en la tupla
tupla=(100,'hola', [1,2,3], 4.6, -30, 100)
c = tupla.count(100) # 2
print(c)
c = tupla.count('hola') # 1
print(c)
c = tupla.count("pepe") # 0
print(c)

"""

```
# Tiene formato de código
```

## Conjuntos (set)
Colecciones desordenadas de elementos únicos(no se pueden repetir).
Es muy utilizada cuando queremos eliminar elementos repetidos"""

conjunto1 = {1,2,3,3} # solo tiene 3 elementos
conjunto2 = set() # esto es un conjutno vacio

print(conjunto1) # {1,2,3}
print(conjunto2)

#.add Añade un valor al conjunto
conjunto = {1,2,3}
conjunto.add(4)
print(conjunto)
conjunto.add(0)
print(conjunto)
conjunto.add('h')
print(conjunto)
conjunto.add(3.5)
print(conjunto)

#.discard quitamos un elemento del conjunto
conjunto = {1,2,3}
conjunto.discard(2)
print(conjunto) # {1,3}

# in  me determina si un elemento está dentro del conjunto (set)
conjunto = {'Pepe', 'Bea', 'Angel'}
print('Bea' in conjunto) # True
print('bea' in conjunto) # False
print('Manolo' in conjunto) # False

print('Bea' not in conjunto) # False

# set()  convertir una lista en un conjunto
lista = [1,2,3,1,5]
conjunto = set(lista) # {1,2,3,5}
print(conjunto)

# list() convertir un conjuto en una lista
conjunto = {1,6,2}
lista = list(conjunto) # [1,2,6]
print(lista)

# pop()
#Saca” un objeto del conjunto, lo que significa que:
#lo elimina del conjunto
#la llamada al método pop() devuelve ese objeto
#Importante: el objeto extraído puede ser cualquiera, no sigue ningún orden
#Lanza excepción KeyError si el conjunto está vacío
s = {1, 2, "hola", 3.14}
e1 = s.pop()
print(e1)
print(s)

# remove()
#Elimina el objeto deseado del conjunto
#Debemos indicar como parámetro el valor del objeto a eliminar
#(p.ej. el número 2 o un string que sea “hola”)
#Lanza excepción KeyError si el objeto no está en el conjunto
conjunto = {1, 2, 3, 4, 5}
print(conjunto)
conjunto.remove(1)
conjunto.remove(4)
print(conjunto)

"""Copiar conjuntos"""

#podemos hacer copias de conjuntos
c={1,2,3}
c2=c #esto no funciona ya que c2 es una referencia a c (es el mismo conjunto)
c2=c.copy() #ahora si modifico c2 no afectará a c y vicevesa.
#podemos borrar los elementos de un conjunto
c={1,2,3}
c.clear() #devuelve set()
print(c)
print(c2)

# conjuntos disjuntos
c1 = {1,2,3}
c2 = {3,4,5}
c3 = {-1,99}
c4 = {1,2,3,4,5}
#podemos ver si dos conjuntos son disjuntos(no tienen ningún elemento en común)
print( c1.isdisjoint(c3) ) #devuelve True (no concuerda ningun elemento)
print( c1.isdisjoint(c2) )#devuelve False (concuerda el 3)

# Conjuntos subconjuntos
c1 = {1,2,3}
c2 = {3,4,5}
c3 = {-1,99}
c4 = {1,2,3,4,5}
#podemos ver si un conjunto es un subconjunto de otro
print( c1.issubset(c4) )#devuelve true (el conjunto 1 forma parte del conjunto 4)
print( c2.issubset(c4) )#devuelve true (el conjunto 2 forma parte del conjunto 4)
print( c3.issubset(c4) )#devuelve false (el conjunto 3 no está dentro del conjunto 4)

# Conjuntos superconjuntos
c1 = {1,2,3}
c2 = {3,4,5}
c3 = {-1,99}
c4 = {1,2,3,4,5}
#podemos ver si un conjunto es un superconjunto (contenedor) de otro conjunto
print( c4.issuperset(c1) ) #devuelve True
print( c4.issuperset(c2) ) #devuelve True
print( c3.issuperset(c1) ) #devuelve False

# Unión de conjuntos
c1 = {1,2,3}
c2 = {3,4,5}
c3 = {-1,99}
c4 = {1,2,3,4,5}
#podemos unir conjuntos
print( c1.union(c2) ) #devuelve {1,2,3,4,5} (recuerda que los repetidos se borran)
print(c1) #cuidado, esto no actualiza c1, sino que devuelve un conjunto
#si queremos que se actualice el conjunto usaremos update
c1.update(c1.union(c2)) #devuelve {1,2,3,4,5} y además guarda ese resultado en c1
print(c1)

# Elementos diferentes en un conjunto
c1 = {1,2,3}
c2 = {3,4,5}
c3 = {-1,99}
c4 = {1,2,3,4,5}
#podemos encontrar elementos distintos entre dos conjuntos
print( c1.difference(c2) ) #devuelve {1,2}
#ojo, esto no actualiza c1 solo devuelve un conjutno, si queremos que actualice c1, haremos:
c1.difference_update(c2)  #devuelve {1,2} y además actualiza c1
print(c1)

# Intersección de conjuntos
c1 = {1,2,3}
c2 = {3,4,5}
c3 = {-1,99}
c4 = {1,2,3,4,5}
#obtener un conjunto con los elementos comunes
print( c1.intersection(c2) ) #esto devuelve {3} (tampoco actualiza c1
#si queremos que se actualice c1
c1.intersection_update(c2) # devuelve {3} y actualiza c1
print(c1)

# diferencia simetrica de conjuntos
c1 = {1,2,3}
c2 = {3,4,5}
c3 = {-1,99}
c4 = {1,2,3,4,5}
#seria al contrario que intersect, devuelve todos los elementos que no concuerdan
print( c1.symmetric_difference(c2) )#devuelve {1,2,4,5} (tampoco actualiza c1)
# para que actualice
c1.symmetric_difference_update(c2) #devuelve {1,2,4,5} (actualiza c1)
print(c1)

"""## Diccionarios
Almacena los elementos de forma clave-valor
"""

# Ver el tipo de una colección
a=[2,3]
print( type(a) ) # <class 'list'>
a=(2,3)
print( type(a) ) # <class 'tuple'>
a={2,3}
print( type(a) ) # <class 'set'>
a=set()
print( type(a) ) # <class 'set'>
a=set( [1,2] )
print( type(a) ) # <class 'set'>
a={}
print( type(a) ) # <class 'dict'>

# creando diccionarios
conjunto={1,2,4} # conjunto / set
diccionarioVacio = {} # diccionario vacio
diccionario = {10:'Angel' , 30:'Pepe', 32:'Bea'} # diccionario

# accediendo a un valor del diccionario a través de su clave
colores={'rojo':'red', 'negro':'black', 'naranja':'orange'}
v = colores['naranja'] # nos devuelve el valor orange
print(v)

# modificando un valor del diccionario
colores={'rojo':'red', 'negro':'black', 'naranja':'orange'}
colores['naranja'] = 'laranxa'
print(colores)

# añadir elementos al diccionario
colores={'rojo':'red', 'negro':'black', 'naranja':'orange'}
colores['azul']='blue' # añadir el nuevo elemento al final
print(colores)

# quitar un elemento del diccionario
colores={'rojo':'red', 'negro':'black', 'naranja':'orange'}
del( colores['rojo'] )
print(colores)

# no puede existir un elemento con la misma clave
colores={'rojo':'red', 'negro':'black', 'naranja':'orange','rojo':'red'}
print(colores)

# recorrer un diccionario mostrando las claves
colores={'rojo':'red', 'negro':'black', 'naranja':'orange'}
for key in colores:
  print(key)

# recorrer un diccionario mostrando sus valores
colores={'rojo':'red', 'negro':'black', 'naranja':'orange'}
for key in colores:
  print( colores[key] )

# .items: recorrer un diccionario mostrando la clave y el valor
colores={'rojo':'red', 'negro':'black', 'naranja':'orange'}
for key, value in colores.items():
  print(key , '-' , value)

# obtener una lista con todos sus valores
colores={'amarillo':'yellow', 'azul':'blue', 'verde':'green'}
colores.values() #devuelve dict_values(['yellow','blue','green'])
#para recorrer
for v in colores.values():
	print(v)

# mezclando diccionarios
personajes = [] # lista
p = {'nombre':'Gandalf', 'clase':'mago', 'raza':'humano'} # diccionario
personajes.append(p) # insertar el diccionario al final de la lista
p = {'nombre':'Legolas', 'clase':'arquero', 'raza':'elfo'} # diccionario
personajes.append(p) # inserto el diccionario al final de la lista

for personaje in personajes:
  print(personaje['nombre'] , personaje['clase'])

# Ejercicios
t=(1,2,3,4,5)
print(t[2:]) # (3,4,5)

t=(1,2,2,3,3,3)
t.count(3) #3

#t={1,2,2,3,3,3}
#t.count(3) #

c={1,2,2,3,3,3} # {1,2,3}
print( list(c) ) # [1,2,3]

d={'nombre':'juan', 'edad':50}
d['apellidos']='Perez'
d['edad'] += 4
print(d) # {'nombre':'juan', 'edad':54 , 'apellidos':'Perez'}

# eliminar elementos del diccionario
colores={'amarillo':'yellow', 'azul':'blue', 'verde':'green'}
v = colores.pop('amarillo', 'no se encuentra') #el diccionario quedará con {'azul':'blue', 'verde':'green'}
print(v)
v = colores.pop('negro', 'no se encuentra') #devuelve 'no se encuentra'
print(v)


#podemos vaciar un diccionario
colores.clear() #devuelve {}

# comprobar si una clave exite
colores={'amarillo':'yellow', 'azul':'blue', 'verde':'green'}
if 'azul' in colores:
  print('si')
else:
  print('no')

"""## Pilas
LIFO: last in first out. Último en llegar es el primero en salir

Las pilas recuerda a un bote patatas de pringles
"""

# Crear una pila
pila=[2,6,4,8]

# Las pilas no son más que listas
print(type(pila)) # <class 'list'>

pila=[2,6,4,8]

#Añadir elementos a la pila (siempre al final)

pila.append(5) #añade un 5 al final de la lista
print(pila)

# Eliminar elmentos de la pila (siempre por el final)
valorEliminado = pila.pop() #devuelve el elemento al final de la lista y además lo elimina
print(pila)



"""## Colas
FIFO: first in first out. Primero en entrar es el primero en salir.

Se asemeja a la cola de un supermercado
"""

#  Creación de una cola
#al no usarse mucho hay que importar la librería
from collections import deque

# podemos crear una cola vacia
cola = deque()

# podemos crear una cola directamente con información
cola = deque( ['ana','juan','miguel'] )

# Las colas son clases especiales
print(type(cola)) # <class 'collections.deque'>

from collections import deque
cola = deque( ['ana','juan','miguel'] )
print(cola) #deque(['ana', 'juan', 'miguel'])

# Añadir elementos a la cola (se añade al final)
cola.append('rosa') #esto añade al final a 'rosa'
print(cola) #deque(['ana', 'juan', 'miguel', 'rosa'])

# Obtener el primer elemento (son su eliminación) de la cola
elemento = cola.popleft() #devuelve el primer elemento que será 'ana' y además lo saca de la lista

print(cola) #deque(['juan', 'miguel', 'rosa'])

"""#Estructuras de control

##IF
"""

a = 5
if a==5:
  print("a vale cinco")
  print("te repito que a vale cinco")

print("Adios")

a = 5
b = 10
if a==5:
  print("a vale cinco")
  if b==10:
    print("b vale diez")

"""## if else"""

n=10
if n==10:
  print("n vale 10")
else:
  print("n no vale 10")

"""## else if (elif)"""

a = 2
if a==1:
  print("has seleccionado la primera opcion")
elif a==2:
  print("has seleccionado la segunda opcion")
elif a==3:
  print("has seleccionado la tercera opcion")
else:
  print("error")

"""## if simplificado"""

# supongamos este ejemplo sencillo
idioma = 'gl'
if idioma == 'es':
  valor = 'Español'
else:
  valor = 'Ingles'
print(valor)


# El ejemplo anterior tambien se puede escribir de forma acortada
valor = 'Español' if idioma =='es' else 'Ingles'
print(valor)

nombre = input('Inserta un nombre')
valor = 'SI' if nombre in ['Angel','Bea','Pepe'] else 'NO'
print(valor)

x = 33
print(  'par' if x%2==0 else 'impar' )

"""## Ejercicio
Pedir una nota por teclado y mostrar la calificación
- mas de 9 sobresaliente
- de 7 a 8 notable (incluido el 7 y no incluido 9)
- de 6 a 7 bien (incluido el 6)
- de 5 a 6 suficiente (incluido el 5)
- menos de 5 insuficiente




"""

nota = float ( input("Inserta la nota") )
if nota >= 9:
  print("sobresaliente")
elif nota >= 7:
  print("notable")
elif nota >=6:
  print("bien")
elif nota >=5:
  print("suficiente")
else:
  print("insuficiente")

#pass
a=5
if a==5:
  pass
print("adios")

"""##If in"""

letras = ['a','b','c','d']
if 'c' in letras:
  print("la letras se encuentra en la lista")
else:
  print("la letra no se encuentra en la lista")

"""##Switch (segun sea)
No existe en python

## While (mientras)
"""

c=0
while c<=5:
  c+=1 #c = c + 1
  print("c vale", c)

"""## While else"""

c=0
while c<=5:
  c+=1 #c = c + 1
  print("c vale", c)
else:
  print("Se ha terminado de ejecutar el bucle y c vale",c)

"""## break"""

c=0
while c<=5:
  c+=1 #c = c + 1
  if c==3:
    print("cuidado c vale 3")
    break
  print("c vale ",c)

"""## continue"""

c=0
while c<=5:
  c+=1 #c = c + 1
  if c==3:
    print("cuidado c vale 3")
    continue
  print("c vale ",c)

"""## bucle iterativo for in"""

numeros = [2,3,4,5,7]
for n in numeros:
  print(n)

# tenemos una lista de números y queremos duplicar cada uno
# de sus valores [1,2,3] --> [2,4,6]
numeros=[1,2,3]
i=0
for n in numeros:
  numeros[i] *= 2 // falla si usamos n*=2
  i+=1

print(numeros)

"""## Enumerate"""

numeros=[1,2,3]
for i,n in enumerate(numeros):
  numeros[i] *= 2
print(numeros)

"""*texto en cursiva*## for range"""

for i in range(10):
  print(i) # los numeros 0 al 9

for i in range(10,15):
  print(i) # los numeros 10 al 14

for i in range(2,10,2):
  print(i) # los nº del 2 al 9 saltando de dos en dos



"""# Argumentos de la linea de comandos
Paso de argumentos cuando se ejecuta un script de python
"""

# $   python mi_script.py 6 "Angel" 9
import sys


print("lista argumentos", sys.argv)
print("El nombre del script es", sys.argv[0])
print("primer argumento", sys.argv[1])  # 6
print("total argumenos", len(sys.argv)) # 4

"""# Funciones"""

# Definición de una función
def saludo():
  print("hola")
  print("adios")

# para llamar a la función
saludo()

# Problemas con las variable externas

def test():
  n = 5
  print(n)


test() # 5
n=10
test() # 5
print(n) # 10

# devolucion de valores

def dime_tu_nombre():
  return "Pepe"

nombre = dime_tu_nombre()
print(nombre) # Pepe

# devolución de multiples valores
def dimes_tus_datos_personales():
  return "Angel", 33, ['informatica', 'deportes'] # esto es una tupla

nombre, edad, gustos = dimes_tus_datos_personales()

print(nombre)
print(edad)
print(gustos)

# Las funciones admiten parametros
def sumar(num1, num2): # función con 2 parametros
  return num1 + num2


r = sumar(3,4) # llamada a la función con 2 argumentos
print(r)

#r = sumar()  # error
#r = sumar(5) # error

# funciones con orden cambiado en los parametros
def restar(num1, num2):
  return num1-num2

r = restar(4,6)
print(r)

r = restar(num2=4, num1=6)
print(r)

# parametros por defecto
def restar(num1=0, num2=0):
  return num1-num2

r = restar(5,1) # 4
print(r)

r = restar() # 0 - 0  = 0
print(r)

r = restar(5) # 5 - 0  = 5
print(r)

#controlar el paso de parametros correctos
def multiplicar(num1=None, num2=None):
  if num1 == None or num2 == None:
    print("El nº de parametros es incorrecto")
    return 0
  else:
    return num1*num2

r = multiplicar(3,4) # 12
print(r)

r = multiplicar(5) # 0 (mostrando el error)
print(r)

def recortar(frase, cantidad):
  return frase[:cantidad]
frase="Lorem ipsum dolor sit amet, consectetur adipiscing elit"
print(recortar(frase,3))

# No se permite la sobrecarga (se sobreescribe la última función añadida)
def func1(num):
    print(num*2)


def func1(num1, num2):
    print(num*num)

func1(3)

#Paso de un objeto inmutable (entero)
def doblar_valor(num):
  num = num * 2

n = 10
doblar_valor(n)
print(n) # muestra 10

#Paso  de un objeto mutable (lista)
def doblar_valores(lista_valores):
  for i,v in enumerate(lista_valores):
    lista_valores[i] *= 2  # v*=2 no funciona



l = [3,4,5]
doblar_valores(l)
print(l) # muestra [6,8,10]

#Paso de un objeto inmutable (cadena)
def pasar_mayusculas(texto):
  texto = texto.upper()

t = "angel"
pasar_mayusculas(t)
print(t) # muestra "angel"

"""## Parametros por valor y por referencia

En Python no se concibe la dialéctica paso por valor/referencia, porque el lenguaje no trabaja con el concepto de variables sino objetos y referencias.

Al realizar la asignación a = 1 no se dice que “a contiene el valor 1″ sino que “a referencia a 1″.

Así, en comparación con otros lenguajes, podría decirse que en Python** los parámetros siempre se pasan por referencia**.

Partimos del concepto de que hay datos que son mutables (pueden cambiar su valor) y otros que son inmutables (no pueden cambiar)

*   Ej las listas, conjuntos(set) y los diccionarios son mutables
*   Ej las tuplas, las cadenas de texto,  los numeros ... son inmutables

En el caso de los objetos inmubles, una vez creados, su valor no puede ser modificado. ¿Cómo, no puedo acaso hacer a = 1 y luego a = 2? Claro, pero desde la perspectiva del lenguaje, no estás cambiando el valor de a de 1 a 2 sino quitando la referencia a 1 y poniéndosela a 2. En términos más simples, no “cambias” el valor de un objeto sino que le asignas una nueva referencia.


"""

# Como simular el pasar un objeto que es inmutable para que parezca que se pasa como mutable (usando return)
def doblar_valor(num):
  return num * 2

n= 10
n = doblar_valor(n)
print(n) # 20

# Como simular el pasar un objeto que es mutable para que parezca que se pasa como inmutable
def doblar_valores(lista):
  for i,v in enumerate(lista):
    lista[i] *= 2

l = [1,2,3]
doblar_valores(l[:])
print(l) # [1,2,3]

# Ejemplo
def triplicar_valores(lista):
   lista = [5,6,7]
   for i,v in enumerate(lista):
    lista[i] *= 3

l = [1,2,3]
triplicar_valores(l)
print(l)

"""[texto del enlace](https://)## Parámetros indeterminados"""

#nº Parametros indeterminados (como una tupla)
def pinta(*args):  # args es una tupla
  print(args) # ('hola', 5, [1, 2, 3])
  print(args[1])  # 5


pinta("hola", 5, [1,2,3])

def concatena(*args):  # args es una tupla
  r=""
  for a in args:
    r+=a
  return r
print(   concatena("hola", "que", "tal")   )

#nº Parametros indeterminados (como un diccionario
def pinta(**args):  # args es una diccionario
  print(args) # {'nombre': 'angel', 'valor': 5, 'listaDatos': [1, 2, 3]}
  print(args["valor"]) # 5



pinta(nombre="angel", valor=5, listaDatos=[1,2,3])

"""##Las funciones de conversión de valores

---


"""

# Funciones de conversion

#convertir una cadena en un numero entero
n = int("10")
print(n)


#convertir una cadena a un numero flotante
n = float("10.6")
print(n)

#convertir un numero en una cadena
c = str(10.8)
print(c)

#convertir un numero en binario
b = bin(4)
print(b)

#convetri un numero en hexadecimal
h = hex(17)
print(h)

#convertir un binario en un numero
n = int('0b100', 2)
print(n)

#convertir un hexadeciaml en numero
n = int('0x11', 16)
print(n)

"""## Funciones recursivas"""

def cuenta_atras(num):
  num-=1
  if num > 0:
    print(num)
    cuenta_atras(num)
  else:
    print("termino la cuenta atrás")
  print("fin", num)

cuenta_atras(5)

def factorial(num):
	print("valor inicial=",num)
	if num>1:
		num = num * factorial(num-1)
	print("valor inicial=",num)
	return num

factorial(5)

# funciones matematicas
n = abs(-10)
print(n) # 10

n = round(5.5)
print(n) # 6

n = round(5.4)
print(n)# 5

n = round(5.6)
print(n)# 6

n = eval('2+4')
print(n) # 6

v = 1
n = eval('3+v+2')
print(n) # 6

# longitud de algo
n = len([1,3,4])
print(n) # 3


n = len( "Angel" )
print(n) # 5

# Tipado estático de parametros
def saluda(nombre: str):
  return nombre

r = saluda("Angel")
print(r)

def saluda2(nombre: str) -> str:
  return nombre

print( saluda("Angel") )

"""si utilizamos el static type checker conocido como Mypy, es posible detectar errores en tiempo de compilación. Mypy funciona como un linter, indicando errores generados por inconsistencia en los tipos de datos.

\> pip3 install mypy  # Para python3

Una vez descargado puedes utilizarlo escribiendo en la linea de comandos:

\> mypy nombre_del_archivo.py

\> python3 -m mypy nombre_del_archivo.py  # Otra opción

```
# Tiene formato de código
```

# Control de errores
"""

# Constrol de fallos en el código, el código de except se ejecuta si hay probemas
try:
  n = 0
  r = 2 / n
  print(r)

except:
  print("error al dividir por cero")

# Constrol de fallos en el código,
# el código de except se ejecuta si hay probemas
# el código de else se ejecuta si no ha habido problemas
try:
  n = 0
  r = 2 / n
  print(r)

except:
  print("error al dividir por cero")
else:
  print("todo ha ido correctamente (se ejecuta si no hay problemas)")

# Constrol de fallos en el código,
# el código de finally se ejecuta siempre, util cuando necesitamos cerrar ficheros o BD
try:
  n = 0
  r = 2 / n
  print(r)

except:
  print("error al dividir por cero")
finally:
  print("esto siempre se ejecuta")

# Podemos controlar exactamente cual ha sido la excepción que ha 'saltado'
try:
  n = 0
  r = 2 / n
  print(r)

except Exception as e:
  print("error:", type(e).__name__)

# Podemos controlar multiples exepciones
try:
  n = 0
  r = 2 / n
  print(r)

except TypeError:
  print("Problemas con los tipos")
except ValueError:
  print("Problemas con el valor")
except ZeroDivisionError:
  print("Problemas dividiendo entre cero")
except Exception:
  print("Problema generico")

# Ejemplo: Lanzar excepciones
def cuadrado(numero):
  if str(numero).isdigit() == False:
    raise ValueError("El parametro no es un número")

  numero **= 2
  print(numero)

try:
  cuadrado("hola")
except:
  print("error")

"""# Clases

[texto del enlace](https://)Las clases son los moldes de los objetos
El mode de hacer galletas sería la clase. Y la galleta el objeto.
"""

# así definimos una clase
class Galleta:
  pass

# instanciación de un objeto (no se usa NEW)
una_galleta = Galleta()
otra_galleta = Galleta()

# atributos de las clases
class Galleta:
  pass

una_galleta = Galleta()
una_galleta.sabor = "dulce"
una_galleta.color = "marron"
una_galleta.radio = 5

print("La galleta tiene sabor", una_galleta.sabor) # dulce

class Galleta:
  con_chocolate = False

una_galleta = Galleta()
print( "Tiene chocolate:",una_galleta.con_chocolate )

una_galleta.con_chocolate = True
print( "Tiene chocolate:",una_galleta.con_chocolate )

# init y self
# init es un método especial qeu se ejecuta al crearse el objeto (constructor)
# self hace referencia al propio objeto y sirve para diferenciar entre el ámbito
# de clase y el ámbito de método
class Galleta:
  def __init__(self):
    print("has creado una galleta")

una_galleta = Galleta()

# referencia a atributos con self
class Galleta:
  con_chocolate = False

  def __init__(self):
    pass

  def untar_con_chocolate(self):
    self.con_chocolate = True

una_galleta = Galleta()
una_galleta.untar_con_chocolate()
print("La galleta tiene chocolate: ", una_galleta.con_chocolate)

# construcotr __init__ con parámetros
class Galleta:
  con_chocolate = False

  def __init__(self, sabor, color, radio):
    self.sabor = sabor
    self.color = color
    self.radio = radio
    print("Se ha creado una galleta con {} {} {}".format(sabor,color, radio) )

una_galleta = Galleta("fresa", "rojo", 5)

print("Tiene chocolate:",una_galleta.con_chocolate)
print("Su sabor es:",una_galleta.sabor)

#Type

v = type(8)
print(v)

v = type(5.2)
print(v)

v = type('hola')
print(v)

v = type( [1,2,3] )
print(v)

v = type( True )
print(v)

v = type( {1,2,3} )
print(v)

v = type( (1,2,3) )
print(v)

v = type(  {'a':5, 'b':7} )
print(v)

class Galleta:
  pass
una_galleta = Galleta()
v = type( una_galleta )
print(v)


def miFuncion():
  pass
v = type(miFuncion)
print(v)

# Destructor de la clase __del__
class Galleta:
  con_chocolate = False
  def __del__(self):
    print('La galleta se ha destruido')
  def __init__(self):
    print('La galleta se ha creado')


print('El programa se inicia')

def miFuncion():
  una_galleta = Galleta()

miFuncion()
print('El programa se terminó')

# Metodo __str__
# Este método se ejecuta cuando intentando imprimir una instancia del objeto por
# pantalla (con print) o cuando intentamos convertir datos usando str

class Galleta:
  con_chocolate = False
  #sabor = "Cacao"

  def __init__(self, sabor, color):
    self.sabor = sabor
    self.color = color

  def __str__(self):
    return "Galleta:"+ self.sabor + "-" + self.color



una_galleta = Galleta("limon", "amarillo")
print(una_galleta)

# convierte una galleta a texto
datoTextual = str(una_galleta)
print(datoTextual)

# Tamaño de objetos __len__
class Galleta:
  def __init__(self, color, radio):
    self.color = color
    self.radio = radio

  def __len__(self):
    return int(3.1415 * self.radio **2 ) # area

una_galleta = Galleta("rojo", 10)
print( len(una_galleta) )

#nombre="angel"
#len(nombre) #5

#Objetos dentro de objetos
class Pelicula:
  def __init__(self, titulo, duracion, lanzamiento):
    self.titulo = titulo
    self.duracion = duracion
    self.lanzamiento = lanzamiento

  def __str__(self):
    return '{} {}'.format(self.titulo, self.lanzamiento)



class Catalogo:
  peliculas = []

  def __init__(self, peliculas=[]):
    self.peliculas = peliculas

  def agregar(self, pelicula):
    self.peliculas.append(pelicula)

  def mostrar(self):
    for p in self.peliculas:
      print(p)


p1 = Pelicula("El Hobbit", 174, 2012)
p2 = Pelicula("Alien", 200, 1978)

c = Catalogo( [p1,p2] )
c.mostrar()
print("---------------------------")

c.agregar( Pelicula("El padrino", 300, 1974) )
c.mostrar()

# Encapsulación
# La capacidad de impedir el acceso a ciertos atributos y metodos (privados)
class Ejemplo:
  __atributo_privado = "Esto es inalcanzable desde fuera"
  atributo_publico = "Esto si es accesible desde fuera"

  def __metodo_privado(self):
    return self.__atributo_privado

  def metodo_publico(self):
    return self.__atributo_privado

e=Ejemplo()
#e.__atributo_privado  #Error
e.atributo_publico

#e.__metodo_privado()  #Error
e.metodo_publico()

#Herencia
class Producto:
  def __init__(self, ref, nombre):
    self.ref = ref
    self.nombre = nombre

  def __str__(self):
    return "{} - {}".format(self.ref, self.nombre)


class Alimento(Producto):
  def __init__(self, ref, nombre, distribuidor):
    self.distribuidor = distribuidor
    #super().__init__(ref, nombre)
    Producto.__init__(self,ref,nombre)

  def __str__(self):
    return """
    REF\t{}
    NOMBRE\t{}
    DISTRIBUIDOR\t{}
    """.format(self.ref, self.nombre, self.distribuidor)

p = Producto(444, "Manzanas")
#print(p)
a = Alimento(777, "Peras", "Frutas nieves")
print(a)

# En python se permite la herencia multiple (en java NO)
class A:
  def __init__(self):
    print("Creada la clase A")

class B:
  def __init__(self):
    print("Creada la clase B")

class C(A,B):
  def __init__(self):
    #super().__init__()
    A.__init__(self)
    B.__init__(self)
    print("Creada la clase C")

c = C()

#isinstance
class Alimento:
  def __init__(self, color, precio):
    self.color = color
    self.precio = precio
class Coche:
  def __init__(self, precio):
    self.precio = precio


p = Alimento("rojo", 34)
#p = Coche(15000)

if isinstance(p, Alimento):
  print("p es un alimento")
elif isinstance(p, Coche):
  print("p es un coche")
else:
  print("p no es un alimento ni un coche")

# Sobrecarga de operadores

class Persona:
  def __init__(self, nombre, edad):
    self.nombre = nombre
    self.edad = edad

  def __add__(self, otra):
    return self.edad + otra.edad

  def __sub__(self, otra):
    return self.edad - otra.edad

  def __pow__(self, otra):
    return self.nombre + " " + otra.nombre

  def __gt__(self, otra):
    if(self.edad > otra.edad): return "es mas viejo"
    elif(self.edad < otra.edad): return "es mas joven"
    else: return "son iguales en edad"

  def __lt__(self, otra):
    return self.edad < otra.edad



p1 = Persona("Pedro", 30)
p2 = Persona("Rosa", 22)


r = p1 + p2 # sobrecargo el operador suma __add__
print(r) # 52
r = p1 - p2 # sobrecargo el operador resta __sub__
print(r) # 8
r = p1 ** p2 # sobrecargo el operador elevar __pow__
print(r)
r = p1 > p2
print(r)
r = p1 < p2
print(r)

"""## Tipos de métodos en la clase
- De instancia (los metodos normales)  metodo(self)
- Estaticos metodo()
- De clase metodo(cls)

"""

# Métodos estáticos (se omite el self)
# en este ejemplo ping es un atributo statico
class Servidor:
  def __init__(self, ip, puerto):
    self.ip = ip
    self.puerto = puerto

  @staticmethod
  def ping(ip):
    print('lanzo un ping a una ip')

s = Servidor('localhost', 3000)
s.ping('google.com')
servidor.ping(e)

# Métodos de clase (se omite el self y se usa cls) (Se pueden llamar sin instanciar el objeto)
# en este ejemplo ping es un atributo de clase

class Servidor:
  def __init__(self, ip, puerto):
    self.ip = ip
    self.puerto = puerto
  @classmethod
  def ping(cls, ip):
    print('lanzo un ping a una ip')


Servidor.ping('google.com')

"""Ejercicio:
Crea las siguientes clases en python

![clases](https://cdn.hektorprofe.net/ejemplos_edv/python/EjercicioClases.png)

## Tipos de atributos
- De instancia
- De clase
"""

class Alimento:
  def __init__(self, color, precio):
    self.color = color
    self.precio = precio
  def comer(self):
    self.color = 'black'

# Atributos de clase (no es necesario instanciar un nuevo objeto)
# En este ejemplo pi es un atributo de clase
class Triangulo:
  pi = 3.1415

  def __init__(self, base, altura):
    self.base = base
    self.altura = altura


print(Triangulo.pi)

# Atributos de instancia (es necesario instanciar un nuevo objeto para usarlos)
# En este ejemploo base y altura son atributos de instancia
class Triangulo:
  pi = 3.1415

  def __init__(self, base, altura):
    self.base = base
    self.altura = altura

t = Triangulo(4,6)
print(t.base)
print(t.altura)

"""## Propiedades (property)
Es el equivalente de los getters y setters
"""

class Coche:
    def __init__(self, marca, modelo, velocidad):
        self._marca = marca
        self._modelo = modelo
        self._velocidad = velocidad  # Atributo privado para velocidad


    @property
    def velocidad(self):
        return self._velocidad

    @velocidad.setter
    def velocidad(self, nueva_velocidad):
        if nueva_velocidad < 0: raise ValueError("La velocidad no puede ser negativa.")
        self._velocidad = nueva_velocidad

    @velocidad.deleter
    def velocidad(self):
        print("Eliminando el valor de velocidad")
        del self._velocidad


# Uso
mi_coche = Coche("Toyota", "Corolla", 100)

# Acceso a propiedades
print(mi_coche.velocidad) # 100

# Modificar una propiedad
mi_coche.velocidad = 120
print(mi_coche.velocidad) # 120

# Eliminar una propiedad
del mi_coche.velocidad



"""# Los modulos

"""

# fichero saludador.py

def di_hola():
  print("hola")

def di_adios():
  print("adios")


# fichero prueba.py
import saludador

saludador.di_hola()
saludador.di_adios()

# fichero saludador.py

def di_hola():
  print("hola")

def di_adios():
  print("adios")

# fichero prueba.py
from saludador import *

di_adios()

"""# Los paquetes

**Creamos la siguiente estructura:**

* directorio_padre #esto es una carpeta
	 * paquete #esto es una carpeta
		* __init__.py  #esto es un fichero (especial porque indica que es un paquete)
		* saludador.py #esto es un fichero

Tambien podemos crear estrucutras más complejas
* directorio_padre #esto es una carpeta
	* paquete #esto es una carpeta
    * __init__.py  #esto es un fichero (especial porque indica que es un paquete)
	* entradas
     * __init__.py  #esto es un fichero (especial porque indica que es un paquete)
     * entra.py #esto es un fichero
	* salidas
      * __init__.py  #esto es un fichero (especial porque indica que es un paquete)
      * sale.py #esto es un fichero
"""

#ahora podemos crear un fichero cualquiera. ej prueba.py
from paquete.saludador import *
di_adios()

# El problema viene cuando intento desde un directorio fuera del paquete usarlo.
# Para poder hacer esto, antes hay que instalar el paquete dentro de python.
# Primero creamos un fichero llamado setup.py

# Creamo un fichero setup.py con el siguiente contenido
from setuptools import setup
setup(
	name='un nombre',
	version='0.1',
	description='paquete de ejemplo',
	author='Angel',
	author_email='an@gmail.com',
	url='angel.com',
	scripts=[],
	packages =["paquete"]
)

"""Ahora nos colocamos en la carpeta donde tenemos el setup.py

Ejecutamos el comando

```python setup.py sdist```

esto creará una carpeta llamada dist con un fichero comprimido zip o tar.gz
Este fichero lo podemos compartir con quien queramos (amigos, distribuidor de paquetes)

por último podemos instalarlo

```
cd ruta_donde_esta_fichero_comprimido
pip3 install paquete-0.1.zip
```

Para ver los paquetes instalados usamos el comando

```pip3 list````

Para desinstalar un paquete

```pip3 uninstall nombre_paquete```

Ahrora podemos usarlo en nuestros scripts

```
from paquete.saludador import *
di_adios()
```

# Módulos standar

Lista completa de módulos standar https://docs.python.org/3/py-modindex.html#


copy #para crear copias de colecciones y objetos

collections #para usar listas, colas, etc

datetime #para trabajar con fechas y horas

doctest y unittest #para crear pruebas o test

html, xml y json

pickle #para trabajar con ficheros

math #para trabajar con funciones matemáticas

re # para las expresiones regulares

random #para generar contenido aleatorio

socket #para comunicación por red usando protocolos

sqlite3 #para trabajar con base de datos en memoria sqlite

sys #nos da información del entorno del sistema operativo

threading #crear hilos

tkinter #modulo de interfaz gráfica (botones, formularios, etc)

# Ficheros

## Ficheros de tipo texto
"""

# Crear y escribir en un fichero de texto
texto = 'Una línea con texto\nOtra linea mas con texto'
# abrimos el fichero en modo escritura
fichero = open('fichero.txt', 'w')
# escribimos dentro de ese fichero
fichero.write(texto)
# cerramos el fichero
fichero.close()

from google.colab import files
files.download('fichero.txt')

# Leer un fichero de texto completo

# abrimos el fichero en modo lectura
fichero = open('fichero.txt','r')
# lectura completa del fichero
texto = fichero.read()
print(texto)

# Leer un fichero de texto por lineas

# abrimos el fichero en modo lectura
fichero = open('fichero.txt','r')
# lectura en una lista de lineas
lineas = fichero.readlines()
fichero.close()
# mostramos la linea segunda
print("Linea segunda ",lineas[1])

# mostramos la ultima linea
print("Ultima linea",lineas[-1])

#Abrir un fichero para añadir cosas al final

# abrimos el fichero en modo append
fichero = open('fichero.txt','a')
fichero.write("\nAñado alguna información mas")
fichero.close()

from google.colab import files
files.download('fichero.txt')

# lectura de un fichero que no existe
#fichero = open("esto_no_existe.txt", "r")

# lectura de un fichero que no existe en modo append
fichero = open("esto_no_existe.txt", "a")
fichero.write("hola")
fichero.close()

#@title Texto de título predeterminado
variable_name = 47 #@param {type:"string"}
variable_name = 0 #@param {type:"slider", min:0, max:100, step:1}
# Lectura linea a linea de un fichero
fichero = open("fichero.txt",'r')
l1 = fichero.readline() # lee la primera linea
l2 = fichero.readline() # lee la segunda linea
fichero.close()
print("primera linea:",l1)
print("segunda linea:",l2)

# Lectura secuencial mediante bucle for
fichero = open("fichero.txt",'r')
for linea in fichero:
  print(linea)
fichero.close()

# Lectura secuencial mediante bucle for (otra forma mejor)
with open("fichero.txt",'r') as fichero:
  for linea in fichero:
    print(linea)
  fichero.close()

# Manejo del puntero

fichero = open("fichero.txt", 'r')
# situamos el puntero al principio
fichero.seek(0)

# situamos el puntero en el caracter numero 10
fichero.seek(10)

# leemos los 10 caracteres siguientes a partir del puntero
texto =fichero.read(10)
print(texto)
fichero.seek(2)

textoRestante = fichero.read()
print(textoRestante)


fichero.close()

"""# Documentación con Docstrings

1.   Elemento de lista
2.   Elemento de lista


Todos objetos poseen una variable especial **doc** con la que podemos describir para que sirven las clases, modulos, metodos, atributos, ...
"""

# documentar un método
def saluda(parametro):
  """Este método sirve para saludar por pantalla"""
  print("hola que tal",parametro)

saluda("Angel")

help(saluda)

documentacion = saluda.__doc__
print("El comentario de documentación:",documentacion)

print("El nombre del método es:",saluda.__name__)



class Triangulo:
    """Este es el comentario (docstring) de la clase"""
    def __init__(self):
      """Este es el docstring del constructro"""
      pass
    def area(self):
      """Este es el docstring del método calcular area"""
      pass
t = Triangulo()

help(t)

"""ejemplo

"""

import math

class Circulo:
    """
    Representa un círculo en un plano cartesiano.

    Attributes:
        radio (float): El radio del círculo. Debe ser mayor que cero.
        x (float): La coordenada X del centro del círculo.
        y (float): La coordenada Y del centro del círculo.
    """

    def __init__(self, radio, x=0.0, y=0.0):
        """
        Inicializa un nuevo círculo con un radio y una posición en el plano.

        Args:
            radio (float): El radio del círculo. Debe ser mayor que cero.
            x (float, opcional): La coordenada X del centro. Por defecto, 0.0.
            y (float, opcional): La coordenada Y del centro. Por defecto, 0.0.

        Raises:
            ValueError: Si el radio es menor o igual a cero.
        """
        if radio <= 0:
            raise ValueError("El radio debe ser mayor que cero.")
        self.radio = radio
        self.x = x
        self.y = y


    def getArea(self):
        """
        Calcula el área del círculo.

        Returns:
            float: El área del círculo calculada como π * radio².
        """
        return math.pi * self.radio ** 2



    def estaDentro(self, x, y):
        """
        Verifica si un punto (x, y) está dentro del círculo.

        Args:
            x (float): La coordenada X del punto.
            y (float): La coordenada Y del punto.

        Returns:
            bool: True si el punto está dentro o en el borde del círculo, False en caso contrario.
        """
        distancia = math.sqrt((x - self.x) ** 2 + (y - self.y) ** 2)
        return distancia <= self.radio


    def __repr__(self):
        """
        Representación textual del círculo.

        Returns:
            str: Una cadena que describe el círculo con su radio y posición.
        """
        return f"Círculo(radio={self.radio}, x={self.x}, y={self.y})"


# Uso
circulo = Circulo(5, 0, 0)
print(circulo)  # Salida: Círculo(radio=5, x=0, y=0)

# Verificar si puntos están dentro del círculo
print(circulo.estaDentro(3, 4))  # Salida: True (Está dentro)
print(circulo.estaDentro(6, 0))  # Salida: False (Está fuera)

"""# Genera la documentación usando pydoc:

Ejecuta este comando en tu terminal:

```bash
python -m pydoc -w nombre_fichero_sin_extensión
o
python3 -m pydoc -w nombre_fichero_sin_extensión
````

Esto generará un archivo HTML con la documentación extraída de los docstrings.

Si necesitas un archivo en texto plano, puedes redirigir la salida:
```bash
python -m pydoc -w nombre_fichero_sin_extensión > documentacion.txt
o
python3 -m pydoc -w nombre_fichero_sin_extensión > documentacion.txt
```

```
# Tiene formato de código
```

# Testeo con doctest
"""

def sumar(a, b):
  """
  >>> sumar(5,10)
  15
  """
  return a + b


r = sumar(5,1)
print(r)

if __name__ == "__main__":
  import doctest
  doctest.testmod()

"""Para lanzar solamente los test usamos el comando:

```python -m doctest -v mi_programa.py```

Para ejecutar el programa y mostrar el resultado de los test usamos el comando

`python mi_programa.py -v`

# Bases de datos

# Uso de bases de datos con postgresql

pip install psycopg2
"""

# Conexión al servidor de bd

import psycopg2

conn = psycopg2.connect(
    database="nombre_bd",
    user="tu_usuario",
    password="tu_contraseña",
    host="127.0.0.1",
    port="5432"
)
print("Conexión exitosa")
conn.close()

#crear una tabla en la bd

cursor = conn.cursor()
cursor.execute("""
CREATE TABLE estudiantes (
    id SERIAL PRIMARY KEY,
    nombre VARCHAR(100),
    edad INT,
    curso VARCHAR(50)
)
""")
conn.commit()
print("Tabla creada con éxito")

# insertar datos

cursor.execute("""
INSERT INTO estudiantes (nombre, edad, curso)
VALUES (%s, %s, %s)
""", ("Juan Pérez", 21, "Matemáticas"))
conn.commit()
print("Registro insertado")

# obtener datos

cursor.execute("SELECT * FROM estudiantes")
resultados = cursor.fetchall()
for registro in resultados:
    print(registro)

# modificar datos
cursor.execute("""
UPDATE estudiantes
SET edad = %s
WHERE nombre = %s
""", (22, "Juan Pérez"))
conn.commit()
print("Registro actualizado")

# Controlar excepciones
try:
    conn = psycopg2.connect(...)
    cursor = conn.cursor()
    # operaciones aquí
except psycopg2.Error as e:
    print("Error:", e)
finally:
    if conn:
        conn.close()

# uso de context managers para simplificar codigo

with psycopg2.connect(...) as conn:
    with conn.cursor() as cursor:
        cursor.execute("SELECT * FROM estudiantes")
        print(cursor.fetchall())

"""[texto del enlace](https://)## Uso de bases de datos sqlite"""

# Conectarnos a una base de datos

import sqlite3

conexion = sqlite3.connect('ejemplo.db')
cursor = conexion.cursor()

# ......

conexion.close()

# crear una tabla en la base de datos
import sqlite3

#Nos conectamos a la base de datos
conexion = sqlite3.connect('ejemplo.db')
#Obtenemos el cursos
cursor = conexion.cursor()
#Lanzamos una consulta sql para crear una tabla
cursor.execute("CREATE TABLE usuario (id INTEGER PRIMARY KEY AUTOINCREMENT, nombre VARCHAR(100), email VARCHAR(255)) ")
#guardar los cambios haciendo un commit
conexion.commit()
#Cerramos la conexion con la base de datos
conexion.close()

# Insertar un registro en la base de datos
import sqlite3

#Nos conectamos a la base de datos
conexion = sqlite3.connect('ejemplo.db')
#Obtenemos el cursos
cursor = conexion.cursor()
#Lanzamos una consulta sql para insertar
cursor.execute("INSERT INTO usuario(nombre, email) VALUES('Rosa','rosa@gmail.com')")
#guardar los cambios haciendo un commit
conexion.commit()
#Cerramos la conexion con la base de datos
conexion.close()

# consultando todos los registros
import sqlite3

#Nos conectamos a la base de datos
conexion = sqlite3.connect('ejemplo.db')
#Obtenemos el cursos
cursor = conexion.cursor()
#Consultar los usuarios
for usuario in cursor.execute("SELECT * FROM usuario"):
  print(usuario)

#Cerramos la conexion con la base de datos
conexion.close()

# consultando todos los registros
import sqlite3

#Nos conectamos a la base de datos
conexion = sqlite3.connect('ejemplo.db')
#Obtenemos el cursos
cursor = conexion.cursor()
#Consultar el usuario con id = 1
cursor.execute("SELECT * FROM usuario WHERE id=1")

usuario = cursor.fetchone()
print(usuario)
print("Nombre:",usuario[1])
#Cerramos la conexion con la base de datos
conexion.close()

# Actualizar un registro en la base de datos
import sqlite3

#Nos conectamos a la base de datos
conexion = sqlite3.connect('ejemplo.db')
#Obtenemos el cursos
cursor = conexion.cursor()
#Lanzamos una consulta sql para insertar
cursor.execute("UPDATE usuario SET nombre='Rosita' WHERE id=1")
#guardar los cambios haciendo un commit
conexion.commit()
#Cerramos la conexion con la base de datos
conexion.close()

# Borrar un registro en la base de datos
import sqlite3

#Nos conectamos a la base de datos
conexion = sqlite3.connect('ejemplo.db')
#Obtenemos el cursos
cursor = conexion.cursor()
#Lanzamos una consulta sql para insertar
cursor.execute("DELETE FROM usuario WHERE id=1")
#guardar los cambios haciendo un commit
conexion.commit()
#Cerramos la conexion con la base de datos
conexion.close()

"""## Acceso a bases de datos Mysql

Primero instalamos la dependencia necesaria


```
python -m pip install mysql-connector-python
```
"""

import mysql.connector

conexion = mysql.connector.connect(
  host="localhost",
  user="yourusername",
  password="yourpassword"
)

print(conexion)



"""## Acceso a base de datos MongoDB

Primero instalamos la dependencia

```
python -m pip install pymongo
```
"""

# Cremos una base de datos nueva
import pymongo

mongoCliente = pymongo.MongoClient("mongodb://localhost:27017/")

mongoDB = mongoCliente["mydatabase"]

# Creamos una colección en la base de datos
import pymongo

mongoCliente = pymongo.MongoClient("mongodb://localhost:27017/")
mongoDB = mongoCliente["mydatabase"]

mongoColection = mongoDB["customers"]

#Insertar datos
import pymongo
mongoCliente = pymongo.MongoClient('mongodb://localhost:27017/')
mongoBD = mongoCliente['scores']
mongoColeccion = mongoBD['scores']

doc = {'nombre':'pepe', 'email':'pepe@gmail.com'}
x = mongoColeccion.insert_one(doc)

mongoCliente.close()

#Listar datos
import pymongo
mongoCliente = pymongo.MongoClient('mongodb://localhost:27017/')
mongoBD = mongoCliente['scores']
mongoColeccion = mongoBD['scores']

for p in mongoColeccion.find():
    print(p)

mongoCliente.close()

# Listar 1 documento (el primero que encuentre)
import pymongo

mongoCliente = pymongo.MongoClient("mongodb://localhost:27017/")
mongoBD = mongoCliente["mydatabase"]
mongoColeccion = mongoBD["customers"]

x = mongoColeccion.find_one()

print(x)

# Lanzar una query
import pymongo

mongoCliente = pymongo.MongoClient("mongodb://localhost:27017/")
mongoBD = mongoCliente["mydatabase"]
mongoColeccion = mongoBD["customers"]

myquery = { "address": "Hispanidad 33" }

mydoc = mongoColeccion.find(myquery)

for x in mydoc:
  print(x)

# Ordenar y limitar datos
import pymongo

mongoCliente = pymongo.MongoClient("mongodb://localhost:27017/")
mongoBD = mongoCliente["mydatabase"]
mongoColeccion = mongoBD["customers"]

mydoc = mongoColeccion.find().sort("name").limit(100)
#mydoc = mongoColeccion.find().sort("name", -1)


for x in mydoc:
  print(x)

# borrar datos
import pymongo

mongoCliente = pymongo.MongoClient("mongodb://localhost:27017/")
mongoBD = mongoCliente["mydatabase"]
mongoColeccion = mongoBD["customers"]

myquery = { "address": "Hispanidad 33" }

mongoColeccion.delete_one(myquery)

# Borrar una colección entera
import pymongo

mongoCliente = pymongo.MongoClient("mongodb://localhost:27017/")
mongoBD = mongoCliente["mydatabase"]
mongoColeccion = mongoBD["customers"]

mongoColeccion.drop()

# Actualizar datos de una colección
import pymongo

mongoCliente = pymongo.MongoClient("mongodb://localhost:27017/")
mongoCliente = mongoCliente["mydatabase"]
mongoColeccion = mongoCliente["customers"]

myquery = { "address": "Hispanidad 33" }
newvalues = { "$set": { "address": "Hispanidad 44" } }

mongoColeccion.update_one(myquery, newvalues)

for x in mongoColeccion.find():
  print(x)

"""# Formateo de cadenas

"""

v="hola"
n=4

c="un texto {} y un número {}".format(v,n)
print(c)

c="un texto {1} y un número {0}".format(v,n)
print(c)

c="un texto {texto} y un número {numero}".format(texto=v,numero=n)
print(c)

c="un texto {v} y un número {n}".format(v=v,n=n)
print(c)

c="un texto {v} y esto tambien {v}".format(v=v)
print(c)

# Nueva forma de concatenar cadenas

# Antes hacíamos
nombre = "Héctor"
texto = "Hola {}".format(nombre)
print(texto)


# La nueva sintaxis nos permite ahorrarnos el format:
nombre = "Héctor"
texto = f"Hola {nombre}"
print(texto)

#alineacion a la derecha 30 caracteres
print(  "{:>30}".format("palabra")  )
#                       palabra

#alineacion a la izquierda 30 caracteres
print(  "{:30}".format("palabra") +"otro" )
#palabra                       otro

#alineacion al centro 30 caracteres
print(  "algo"+"{:^30}".format("palabra") +"otro" )
#algo           palabra            otro

#truncar caracteres
print(  "{:.5}".format("palabra")  )  #palab

#truncar caracteres y alineación
print(  "{:>30.5}".format("palabra")  )#                         palab

#formateo de números rellenando con espacio a la izquierda
print(  "{:4d}".format(10)  )   #    10
print(  "{:4d}".format(100)  )  #   100
print(  "{:4d}".format(1000)  ) #  1000



#formateo de números rellenando con ceros a la izquierda
print(  "{:04d}".format(10)  )  #0010

#recortar a 3 en la parte decimal
print( "{:.3f}".format(3.1415926) )  #3.142

#alinear los números por su punto decimal
print( "{:7.3f}".format(3.1415926) )
print( "{:7.3f}".format(143.17) )
#    3.142
#143.170

#alinear los números por su punto decimal y rellenar con números a la izq
print( "{:07.3f}".format(3.1415926) )
print( "{:07.3f}".format(143.17) )
#003.142
#143.170

"""# Funciones lambda"""

# partimos de la siguiente funcion sencilla que suma 2 valores
def suma(x,y):
  return x+y


r = suma(3,4)
print(r) # 7

# Vamos a expresarla en forma de lambda
suma = lambda x,y : x+y

r = suma(3,4)
print(r)

def dividir(x,y):
  return x/y

r = dividir(10,2)
print(r) # 7

# Vamos a expresarla en forma de lambda
dividir = lambda x,y : x/y

r = dividir(10,2)
print(r)

cuadrado = lambda x : x*x
lista = [1,2,3,8]

for elemento in lista:
  print( cuadrado(elemento) )

# calcular el area de triangulos

area_triangulo = lambda b,h:b*h/2
medidas = [  (34,8), (26,8), (44,18) ]

for datos in medidas:
  base = datos[0]
  altura = datos[1]
  print( area_triangulo(base, altura) )

# ejercicio: convertir esta funcion en una lambda
def f(x,y,z):
  return x+y+z

r = f(2,30,400)
print(r)

# solución
r = (lambda x,y,z : x+y+z)(2,30,400)
print(r)

"""# Funciones de orden superior

##map
"""

def cuadrado(numero):
  return numero**2

lista = [-2,4,6,8]

for elem in lista:
  r = cuadrado(elem)
  print(r)

v = list( map(cuadrado, lista)  )
print(v)
# cuadrado(-2)
# cuadrado(4)
# cuadrado(6)
# cuadrado(8)

def fahrenheit(t):
  return 9/5*t+32

def celsius(t):
  return 5/9*(t-32)

temperaturas = [35, 37,37.5,39]

f = list( map(fahrenheit, temperaturas) )
c = list( map(celsius, temperaturas) )

print(f)
print(c)

temperaturas = [35, 37,37.5,39]

f = list( map(lambda t:9/5*t+32, temperaturas) )
c = list( map(lambda t:5/9*(t-32), temperaturas) )

print(f)
print(c)

# funcion map con 2 parámetros
a = [1,2,3,4]
b = [11,12,13,14]

# sumador = lambda x,y:x+y

v = list( map( lambda x,y:x+y, a, b ) )
# sumador(1,11)
# sumador(2,12)
# sumador(3,13)
# sumador(4,14)
print(v)

# Ejercicio dados unos circulos de radio dado, calcula su area (usa lambdas y map)
circulos = [1,2,44,120]

# solución:
import math
#def area_circulo(r):
#  return math.pi*r**2
#area_circulo = lambda r: math.pi*r**2

areas = list(  map(lambda r: math.pi*r**2, circulos)  )
print(areas)

"""## filter"""

def esNegativo(n):
  return n<0

lista = [-3,-2,0,1,9,-5]

negativos = list( filter(esNegativo, lista) )

print(negativos)

lista = [-3,-2,0,1,9,-5]

positivos = list( filter( lambda n : n>0, lista) )

print(positivos)

# dada una lista de numeros
# Mostrar solo los impares (usando lambdas y filter)
lista = [-3,-4, 2, 5, 22, 43]

numeros_impares = list(  filter( lambda x:x%2 , lista ) )
print(numeros_impares)

"""## reduce
![texto alternativo](https://www.python-course.eu/images/reduce_diagram.png)
"""

import functools

lista = [47,11,42,13]

numero = functools.reduce( lambda x,y:x+y, lista)
print(numero)

# calcular el mayor de una lista de numeros
lista = [47,11,42,102,13]

f = lambda a,b: a if (a>b) else b

import functools
mayor = functools.reduce( f, lista )
print(mayor)

# calcular la suma de los 100 primeros números
lista = range(1,101)
from functools import reduce
suma = reduce( lambda a,b:a+b , lista )
print(suma)

# Ejercicio
pedidos = [
    ['1111', 'Pasta' , 4, 10.00],
    ['2222', 'Lomo'  , 5, 56.80],
    ['3333', 'Pan'   , 3, 32.95],
    ['4444', 'Bebida', 3, 24.99]
]

# Sacar por pantalla una lista de ID junto con su coste(precio*cantidad)
# Si el coste es menor que 100€ su coste se incrementará en 10€
# Usar funciones map, filter, reduce y lambas en una sola linea

# Solución
print(list( map( lambda x: (x[0] , x[2]*x[3] if (x[2]*x[3]>=100) else x[2]*x[3]+10) , pedidos ) ))

"""##Comprehension de listas"""

# mostrar de una lista los numeros divisibles por 3
numeros = [135,154,180,193,210,3]
lista = [valor for valor in numeros if valor % 3 == 0]
print(lista)

# tengo una lista de números y quiero obtener su inverso
numeros = [1,2,3] # 1 , 0.5, 0.333

def invertir(x):
  return 1/x

lista_de_inversos = [invertir(i) for i in numeros]
print(lista_de_inversos)

# usando un lambda
lista_de_inversos = [(lambda x:1/x)(i) for i in numeros]
print(lista_de_inversos)

# una forma más simle
lista_de_inversos = [1/i for i in numeros]
print(lista_de_inversos)

# dada una lista de numeros calcular sus cubos (elevar al cubo). Usando Comprehesion de listas
lista = [-3,-5,1,2,3,4,5,6]
cubos = [ i**3 for i in lista ]
print(cubos)


# dada una lista de numeros calcular sus cubos (elevar al cubo), pero de los positivos. Usando Comprehesion de listas
lista = [-3,-5,1,2,3,4,5,6]
cubos = [ i**2 for i in lista if i>0 ]
print(cubos)

"""# Servidores backend (endpoints)

Instalamos las dependencias necesarias


```
pip install Flask
```

... Pendiente ....
"""